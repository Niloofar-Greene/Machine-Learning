data <- read_csv("data_etudiants_socio_rv.csv")
library(readr)
data <- read_csv("data_etudiants_socio_rv.csv")
sample(1:nrow(data), 50, replace=false)
sample(1:nrow(data), 50, replace=FALSE)
sample(1:nrow(data), 50, replace=TRUE)
sample_student=data[A,]
A=sample(1:nrow(data), 50, replace=FALSE)
sample_student=data[A,]
set.seed(5)
rnorm(5)
rnorm(5)
rnorm(5)
rnorm(5)
set.seed(5)
rnorm(5)
set.seed(5)
rnorm(5)
set.seed(5)
rnorm(5)
set.seed(5)
rnorm(5)
set.seed(5)
rnorm(5)
rnorm(5)
rnorm(5)
rnorm(5)
rnorm(5)
library(datasets)
summary(iris)
#**********************************************
# each time you run this block , it gives same results all the time
# but if you change the value in set.seed(), the results will be different each time: different clusters
# it means set.seed() keeps the result intact
# ca garde tjrs la meme maniere d'aller aleatoirement
# le chiffre n'a aucune identite. c le changement de chiffre qui fait la differnece des resultats.
# tirer l'aleatoirement les moy. de k groups
library(datasets)
summary(iris)
#**********************************************
# each time you run this block , it gives same results all the time
# but if you change the value in set.seed(), the results will be different each time: different clusters
# it means set.seed() keeps the result intact
# ca garde tjrs la meme maniere d'aller aleatoirement
# le chiffre n'a aucune identite. c le changement de chiffre qui fait la differnece des resultats.
# tirer l'aleatoirement les moy. de k groups
set.seed(30)
iris2=iris[,1:4]
View(iris)
# standardization des donnees
iris_stand=scale(iris[,1:4])
####################################### methode non-hierarchique - k-means ##################################
# 3 groups
iris_kmeans=kmeans(iris_stand,3,nstart = 1 )
# Cluster means shows the means of 3 groups generated
# Clustering vector shows the group allocation of each of the observation in the dataset
# within cluster sum of squares  (R2) : SSB / SST
iris_kmeans
#rajouter les resultats de k-means dans la table originale (iris)
iris$Cluster=iris_kmeans$cluster
View(iris)
iris_clus1=iris[iris$Cluster==1,]
# compare the mean of all variables of cluster1 with entire dataset using summary
summary(iris_clus1)
summary(iris)
table(iris$Species,iris$Cluster)
View(iris_stand)
################################################## methode hierarchique #######################################################
# distance matrix
table_distance=dist(iris_stand, method = "euclidian")
View(iris)
head(table_distance,20)
#hclust : hierarchical clustering
clust_h=hclust(table_distance, method = "ward.D2")
clust_h
plot(clust_h)
# cut tree into 5 clucters
groups=cutree(clust_h,5)
# Creates dendogram with red boxes around the clusters do the folloing
rect.hclust(clust_h, k=5, border="red")
# H for hierarchic
iris$Cluster_H=groups
table(iris$Species,iris$Cluster_H)
library(datasets)
summary(iris)
#**********************************************
# each time you run this block , it gives same results all the time
# but if you change the value in set.seed(), the results will be different each time: different clusters
# it means set.seed() keeps the result intact
# ca garde tjrs la meme maniere d'aller aleatoirement
# le chiffre n'a aucune identite. c le changement de chiffre qui fait la differnece des resultats.
# tirer l'aleatoirement les moy. de k groups
set.seed(30)
iris2=iris[,1:4]
View(iris)
# standardization des donnees
iris_stand=scale(iris[,1:4])
####################################### methode non-hierarchique - k-means ##################################
# 3 groups
iris_kmeans=kmeans(iris_stand,3,nstart = 1 )
iris_kmeans
# Cluster means shows the means of 3 groups generated
# Clustering vector shows the group allocation of each of the observation in the dataset
# within cluster sum of squares  (R2) : between_SS / total_SS which is SSB / SST
#**********************************************
#rajouter les resultats de k-means dans la table originale (iris)
iris$Cluster=iris_kmeans$cluster
iris_clus1=iris[iris$Cluster==1,]
# compare the mean of all variables of cluster1 with entire dataset using summary
summary(iris_clus1)
summary(iris)
table(iris$Species,iris$Cluster)
# ca montre si on reussi a repliquer species
# it creates a matrix, where column headers are cluster factors, and row headers are species factors
# Le cluster a reusi de regroupr tous les stosa dans un meme cluster,
# et les 2 autres clusters se ressemblent plus, et peut-etre il n'y a plus de variables pour les discriminer
# majorite de cluster 2 est verginica, et il y a 11  versicolor qui ressemblent bq a verginica
# majorite de cluster 3 est versicolor, et il y a 14 verginica qui ressemblent bq a versicolor
################################################## methode hierarchique #######################################################
# distance matrix
table_distance=dist(iris_stand, method = "euclidian")
head(table_distance,20)
#hclust : hierarchical clustering
clust_h=hclust(table_distance, method = "ward.D2")
clust_h
plot(clust_h)
dev.off
# selon le plot , on y va avec 5 groupes
# Creates dendogram with red boxes around the clusters do the folloing
rect.hclust(clust_h, k=5, border="red")
# cut tree into 5 clucters
groups=cutree(clust_h,5)
#try with 3 this time
groups=cutree(clust_h,3)
rect.hclust(clust_h, k=3, border="red")
# H for hierarchic
iris$Cluster_H=groups
table(iris$Species,iris$Cluster_H)
library(datasets)
summary(iris)
#**********************************************
# each time you run this block , it gives same results all the time
# but if you change the value in set.seed(), the results will be different each time: different clusters
# it means set.seed() keeps the result intact
# ca garde tjrs la meme maniere d'aller aleatoirement
# le chiffre n'a aucune identite. c le changement de chiffre qui fait la differnece des resultats.
# tirer l'aleatoirement les moy. de k groups
set.seed(30)
iris2=iris[,1:4]
View(iris)
# standardization des donnees
iris_stand=scale(iris[,1:4])
####################################### methode non-hierarchique - k-means ##################################
# 3 groups
iris_kmeans=kmeans(iris_stand,3,nstart = 1 )
iris_kmeans
# Cluster means shows the means of 3 groups generated
# Clustering vector shows the group allocation of each of the observation in the dataset
# within cluster sum of squares  (R2) : between_SS / total_SS which is SSB / SST
#**********************************************
#rajouter les resultats de k-means dans la table originale (iris)
iris$Cluster=iris_kmeans$cluster
iris_clus1=iris[iris$Cluster==1,]
# compare the mean of all variables of cluster1 with entire dataset using summary
summary(iris_clus1)
summary(iris)
table(iris$Species,iris$Cluster)
# ca montre si on reussi a repliquer species
# it creates a matrix, where column headers are cluster factors, and row headers are species factors
# Le cluster a reusi de regroupr tous les stosa dans un meme cluster,
# et les 2 autres clusters se ressemblent plus, et peut-etre il n'y a plus de variables pour les discriminer
# majorite de cluster 2 est verginica, et il y a 11  versicolor qui ressemblent bq a verginica
# majorite de cluster 3 est versicolor, et il y a 14 verginica qui ressemblent bq a versicolor
################################################## methode hierarchique #######################################################
# distance matrix
table_distance=dist(iris_stand, method = "euclidian")
head(table_distance,20)
#hclust : hierarchical clustering
clust_h=hclust(table_distance, method = "ward.D2")
clust_h
plot(clust_h)
# selon le plot , on y va avec 5 groupes
# Creates dendogram with red boxes around the clusters do the folloing
rect.hclust(clust_h, k=5, border="red")
dev.off
dev.off
dev.off
dev.off
dev.off()
# cut tree into 5 clucters
groups=cutree(clust_h,5)
#try with 3 this time
groups=cutree(clust_h,3)
rect.hclust(clust_h, k=3, border="red")
#try with 3 this time
clust_h=hclust(table_distance, method = "ward.D2")
groups=cutree(clust_h,3)
rect.hclust(clust_h, k=3, border="red")
plot(clust_h)
rect.hclust(clust_h, k=3, border="red")
# H for hierarchic
iris$Cluster_H=groups
table(iris$Species,iris$Cluster_H)
table(iris$Species,iris$Cluster)
table(iris$Species,iris$Cluster_H)
table(iris$Species,iris$Cluster)
table(iris$Species,iris$Cluster_H)
